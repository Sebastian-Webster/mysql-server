CREATE TABLE T1 (
C1 INT PRIMARY KEY,
C2 INT
);
CREATE TABLE T2 (
C1 INT PRIMARY KEY,
C2 INT REFERENCES T1(C1)
);
CREATE VIEW V AS SELECT * FROM T1;
# Requirements for view name: It should be a valid Identifier name.
# Using keyword as a identifier name
CREATE JSON DUALITY VIEW SELECT AS
SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2" : C2
)
FROM T1;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'SELECT AS
SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2" : C2
)
FROM T1' at line 1
CREATE JSON DUALITY VIEW
abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2" : C2
)
FROM T1;
ERROR 42000: Identifier name 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm' is too long
CREATE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2" : C2
)
FROM T1;
# Name conflict handling for view name
CREATE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1
)
FROM T1;
ERROR 42S01: Table 'dv1' already exists
CREATE JSON DUALITY VIEW V
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1
)
FROM T1;
ERROR 42S01: Table 'V' already exists
CREATE OR REPLACE JSON DUALITY VIEW V
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1
)
FROM T1;
ERROR HY000: View 'test.V' of 'SQL' type already exists. Replacing view with mismatched type is not supported.
# "OR REPLACE" clause is supported, if jdv with
# the given name is already present, it should
# replaced with the new definition.
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1
)
FROM T1;
# "IF NOT EXISTS" clause is supported.
CREATE JSON DUALITY VIEW IF NOT EXISTS dv2
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2" : C2
)
FROM T1;
# Top-level SELECT must contain only one JSON_DUALITY_OBJECT()
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_OBJECT(
"_id" , C1,
"C2"  , C2
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: Only JSON_DUALITY_OBJECT() is allowed in the select list of root object's query.
# Only simple SELECT statement is supported, operators like
# UNION, INTERSECT, EXCEPT and complex SELECT like CTEs aren't
# supported and must result into a syntax error if used.
# This is true for both Top-level SELECT and for sub-objects.
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2" : C2
)
FROM T1
UNION
SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2" : C2
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: Invalid JSON duality view definition: Set Operations such as UNION, INTERSECT, EXCEPT and multi-level ORDER are not supported. Object "Root Node" violates this rule.
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
WITH T1_ALIAS AS (
SELECT C1 AS C1_A, C2 AS C2_A
FROM T1
)
SELECT JSON_DUALITY_OBJECT(
"C1_A" : C1_A,
"C2_A" : C2_A
)
FROM T1_ALIAS;
ERROR HY000: Invalid JSON duality view definition: Common Table Expressions (CTE) are not supported. Object "Root Node" violates this rule.
# Requirements for FROM clause
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : T1.C1,
"C2"  : T1.C2
)
FROM T1, T2;
ERROR HY000: Invalid JSON duality view definition: FROM clause must include exactly one table. Object "Root Node" violates this rule.
# Requirements for Keys in JSON_DUALITY_OBJECT:
# There must be a key named "_id" in root object representing
# primary key of the root table. Absence of such key_name in the
# root table json_duality_key_value_pairs must result in an error.
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"C1" : T1.C1,
"C2" : T1.C2,
"T2" : (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1" : T2.C1,
"C2" : T2.C2
)
)
FROM T2
WHERE T1.C1 = T2.C2
)
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: Primary key column of a root object's table must always be projected as "_id".
# Requirements for Values in JSON_DUALITY_OBJECT:
# It must either be a column name, JSON_DUALITY_OBJECT
# or JSON_ARRAYAGG. Usage of any other expression must
# result in a syntax error.
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : T1.C1,
"C2" : 1,
"T2" : (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1" : C1,
"C2" : C2
)
)
FROM T2
WHERE T1.C1 = T2.C2
)
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: JSON_DUALITY_OBJECT value must be either a table column or a sub-query. Object "C2" contains an invalid value.
# Requirements for column name used in the JSON_DUALITY_OBJECT:
# It must reference a valid column in the table that is being
# projected.
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : T1.C1,
"C2"  : T1.C2,
"T2"  : (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1" : T2.C1,
"C2" : T2.C3
)
)
FROM T2
WHERE T1.C1 = T2.C2
)
)
FROM T1;
ERROR 42S22: Unknown column 'T2.C3' in 'field list'
# Projecting virtual columns isn't supported and must result into a
# semantic error if done.
ALTER TABLE T2 ADD COLUMN C3 INT GENERATED ALWAYS AS (C1+C2) VIRTUAL;
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : T1.C1,
"C2" : T1.C2,
"T2" : (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1" : T2.C1,
"C2" : T2.C2,
"VIRTUAL": C3
)
)
FROM T2
WHERE T1.C1 = T2.C2
)
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: Object "T2" projecting "test.T2" includes column "C3" of type "GENERATED". This type of projection is not supported.
# Unlike top-level select, WHERE clause is supported here but it
# must only contain one expression, and that must be of the below form:
# [schema_name .] child_table_name . column_name =
# [schema_name .] parent_table_name . column_name
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id": T2.C1,
"C2" : T2.C2,
"T1" : (
SELECT JSON_DUALITY_OBJECT(
"C1" : T1.C1,
"C2" : T1.C2
)
FROM T1
)
)
FROM T2;
ERROR HY000: Invalid JSON duality view definition: WHERE clause is mandatory with sub-objects. Object "T1" is missing this clause.
# Usage of any other type of condition or usage of AND/OR operator
# in the condition must result in a syntax error.
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id": T2.C1,
"C2" : T2.C2,
"T1" : (
SELECT JSON_DUALITY_OBJECT(
"C1" : T1.C1,
"C2" : T1.C2
)
FROM T1
WHERE T1.C1 = T2.C2 AND 1=1
)
)
FROM T2;
ERROR HY000: Invalid JSON Duality View Definition: The WHERE clause in sub-objects must consist of a single condition being an equality comparison between parent object and sub-object's table columns. Object "T1" violates this rule.
# The JSON_ARRAYAGG() must contain JSON_DUALITY_OBJECT()
# and JSON_DUALITY_OBJECT() must not be empty.
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"C1" : T1.C1,
"C2" : T1.C2,
"T2" : (
SELECT JSON_ARRAYAGG(T2.C2)
FROM T2
WHERE T1.C1 = T2.C2
)
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: Only JSON_DUALITY_OBJECT() is allowed in the argument list of JSON_ARRAYAGG(). Object "T2" violates this rule.
# Requirements for table_annotations_expression
# Tables being projected (i.e. root_table_name or child_table_name
# clauses) in the duality view can optionally have table annotations.
# The following table annotations must be supported:
#    INSERT
#    DELETE
#    UPDATE
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2" : C2
)
FROM T1;
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
WITH (INSERT, UPDATE, DELETE)
"_id" : C1,
"C2" : C2
)
FROM T1;
# Support for column list
# The CREATE OR REPLACE JSON DUALITY VIEW statement does not
# support column list, using column list in the statement should
# result in a syntax error. View column name data is automatically
# added for the JSON duality view.
CREATE OR REPLACE JSON DUALITY VIEW dv1 (data)
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2"  : C2
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: Specifying column list is not supported for duality views.
# Requirement-9: Base Table Requirement for Participating Tables
CREATE OR REPLACE VIEW V1 AS SELECT C1, C2 FROM T1;
CREATE JSON DUALITY VIEW dv2
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2"  : C2
)
FROM V1;
ERROR HY000: Invalid JSON duality view definition: Only base tables can be used to create JSON DUALITY VIEW. "test.V1" is not a base table.
CREATE TEMPORARY TABLE T3 AS
SELECT * FROM T1;
CREATE JSON DUALITY VIEW dv2
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2"  : C2
)
FROM T3;
ERROR HY000: View's SELECT refers to a temporary table 'T3'
# All participating tables must have a defined primary key.
CREATE TABLE T4 (C1 INT, C2 INT);
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2"  : C2
)
FROM T4;
ERROR HY000: Invalid JSON duality view definition: All participating tables should have a primary key, "test.T4" does not have it.
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"_id" : C1,
"C2"  : C2,
"T4"  : (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1" : T4.C1,
"C2" : T4.C2
)
)
FROM T4
WHERE T4.C1 = T1.C1
)
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: All participating tables should have a primary key, "test.T4" does not have it.
# The projection must include the primary key of every
# participating table. If any participating table lacks a
# primary key, or if the primary key is omitted from the projection,
# a semantic error must be generated.
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
"C2" : C2
)
FROM T1;
ERROR HY000: Invalid JSON duality view definition: Primary key column of every table should be projected, object "Root Node" that projects table "test.T1" does not.
# Child tables being projected as part of JSON DUALITY VIEW can
# be related to parent tables in one of below 2 types:
#    1. PK - FK Relationship (or Referential Integrity)
#    2. PK - Any Column Relationship
CREATE TABLE T5 (
C1 INT PRIMARY KEY,
C2 INT,
FOREIGN KEY (C1) REFERENCES T1(C1)
);
# 11.1 PK-FK Relationship (or Referential Integrity):
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
"_id": T5.C1,
"C2": T5.C2,
"T1": (
SELECT JSON_DUALITY_OBJECT(
"C1": T1.C1,
"C2": T1.C2
)
FROM T1 WHERE T1.C2 = T5.C2
)
) FROM T5;
ERROR HY000: Invalid JSON duality view definition: For singleton descendant object, the primary key column of a current object's table must be used in the WHERE condition. For a nested descendant object, the primary key column of the parent object's table must be used in where condition. Object "T1" violates the rule.
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
"_id": T1.C1,
"C2": T1.C2,
"T5": (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1": T5.C1,
"C2": T5.C2
)
)
FROM T5 WHERE T1.C2 = T5.C2
)
) FROM T1;
ERROR HY000: Invalid JSON duality view definition: For singleton descendant object, the primary key column of a current object's table must be used in the WHERE condition. For a nested descendant object, the primary key column of the parent object's table must be used in where condition. Object "T5" violates the rule.
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
"_id": T1.C1,
"C2": T1.C2,
"T5": (
SELECT JSON_DUALITY_OBJECT(
"C1": T5.C1,
"C2": T5.C2
)
FROM T5 WHERE T1.C1 = T5.C1
)
) FROM T1;
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
"_id": T5.C1,
"C2": T5.C2,
"T1": (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1": T1.C1,
"C2": T1.C2
)
)
FROM T1 WHERE T1.C1 = T5.C1
)
) FROM T5;
# 11.2 PK - Any column Relationship:
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
"_id": T5.C1,
"C2": T5.C2,
"T1": (
SELECT JSON_DUALITY_OBJECT(
"C1": T1.C1,
"C2": T1.C2
)
FROM T1 WHERE T1.C1 = T5.C2
)
) FROM T5;
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
"_id": T1.C1,
"C2": T1.C2,
"T5": (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1": T5.C1,
"C2": T5.C2
)
)
FROM T5 WHERE T1.C1 = T5.C2
)
) FROM T1;
# In a case where a parent table is Foreign key child of a child_table,
# usage of the DELETE tag with the child_table must result in a
# semantic error.
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE, DELETE)
"_id": T1.C1,
"C2": T1.C2,
"T2": (
SELECT JSON_DUALITY_OBJECT(WITH DELETE
"C1": T2.C1,
"C2": T2.C2
)
FROM T2
WHERE T1.C1 = T2.C1
)
) FROM T1;
ERROR HY000: Invalid JSON duality view definition: Incorrect annotations for "T2". For singleton child object linked using primary key column with parent, table annotations must enforce both read-only or INSERT and UPDATE. DELETE is not allowed.
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE, DELETE)
"_id": T1.C1,
"C2": T1.C2,
"T2": (
SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE, DELETE)
"C1": T2.C1,
"C2": T2.C2
)
FROM T2
WHERE T1.C1 = T2.C1
)
) FROM T1;
ERROR HY000: Invalid JSON duality view definition: Incorrect annotations for "T2". For singleton child object linked using primary key column with parent, table annotations must enforce both read-only or INSERT and UPDATE. DELETE is not allowed.
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE, DELETE)
"_id": T1.C1,
"C2": T1.C2,
"T2": (
SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE)
"C1": T2.C1,
"C2": T2.C2
)
FROM T2
WHERE T1.C1 = T2.C1
)
) FROM T1;
CREATE TABLE T6 (C1 INT PRIMARY KEY, C2 INT);
ALTER TABLE T2 ADD C4 INT REFERENCES T6(C1);
CREATE OR REPLACE
ALGORITHM = MERGE
DEFINER = current_user()
SQL SECURITY DEFINER
JSON RELATIONAL DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
WITH (INSERT, UPDATE, DELETE)
"_id" : C1,
"C2"  : C2,
"T2"  : (
SELECT JSON_ARRAYAGG(
JSON_DUALITY_OBJECT(
"C1" : C1,
"C2" : C2,
"T6" : (
SELECT JSON_DUALITY_OBJECT(
WITH (INSERT, UPDATE)
"C1" : C1,
"C2" : C2
)
FROM T6
WHERE T6.C1 = T2.C4
)
)
)
FROM T2
WHERE T1.C1 = T2.C2
)
)
FROM T1;
# Requirements for DROP VIEW
# If a duality view with the view_name is present, regardless
# of whether IF EXISTS clause is there or not, the statement
# DROP VIEW must drop the view.
DROP VIEW V, V1;
DROP VIEW IF EXISTS dv1, dv2;
# Cleanup
DROP TABLE T1, T2, T3, T4, T5, T6;
