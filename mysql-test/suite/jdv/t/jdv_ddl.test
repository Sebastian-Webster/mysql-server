########################################################################
#   Test for DDL of JSON duality views.                                #
########################################################################

--source include/have_case_sensitive_file_system.inc

CREATE TABLE T1 (
    C1 INT PRIMARY KEY,
    C2 INT
);

CREATE TABLE T2 (
    C1 INT PRIMARY KEY,
    C2 INT REFERENCES T1(C1)
);

CREATE VIEW V AS SELECT * FROM T1;

--echo # Requirements for view name: It should be a valid Identifier name.
--echo # Using keyword as a identifier name
--error ER_PARSE_ERROR
CREATE JSON DUALITY VIEW SELECT AS
SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2" : C2
)
FROM T1;

--error ER_TOO_LONG_IDENT
CREATE JSON DUALITY VIEW
abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2" : C2
)
FROM T1;

CREATE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2" : C2
)
FROM T1;

--echo # Name conflict handling for view name
--error ER_TABLE_EXISTS_ERROR
CREATE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1
)
FROM T1;

--error ER_TABLE_EXISTS_ERROR
CREATE JSON DUALITY VIEW V
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1
)
FROM T1;

--error ER_JDV_ALTER_OR_REPLACE_NOT_SUPPORTED
CREATE OR REPLACE JSON DUALITY VIEW V
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1
)
FROM T1;

--echo # "OR REPLACE" clause is supported, if jdv with
--echo # the given name is already present, it should
--echo # replaced with the new definition.

CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1
)
FROM T1;

--echo # "IF NOT EXISTS" clause is supported.

CREATE JSON DUALITY VIEW IF NOT EXISTS dv2
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2" : C2
)
FROM T1;

--echo # Top-level SELECT must contain only one JSON_DUALITY_OBJECT()

--error ER_JDV_INVALID_DEFINITION_NO_JSON_OBJECT_IN_ROOT
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_OBJECT(
    "_id" , C1,
    "C2"  , C2
)
FROM T1;

--echo # Only simple SELECT statement is supported, operators like
--echo # UNION, INTERSECT, EXCEPT and complex SELECT like CTEs aren't
--echo # supported and must result into a syntax error if used.
--echo # This is true for both Top-level SELECT and for sub-objects.

--error ER_JDV_INVALID_DEFINITION_NON_SIMPLE_SELECT_NOT_SUPPORTED
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
        "_id" : C1,
        "C2" : C2
    )
    FROM T1
UNION
    SELECT JSON_DUALITY_OBJECT(
        "_id" : C1,
        "C2" : C2
    )
    FROM T1;

--error ER_JDV_INVALID_DEFINITION_CTE_NOT_SUPPORTED
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
WITH T1_ALIAS AS (
    SELECT C1 AS C1_A, C2 AS C2_A
    FROM T1
)
SELECT JSON_DUALITY_OBJECT(
            "C1_A" : C1_A,
            "C2_A" : C2_A
)
FROM T1_ALIAS;

--echo # Requirements for FROM clause

--error ER_JDV_INVALID_DEFINITION_MULTI_TABLES_NOT_SUPPORTED
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : T1.C1,
    "C2"  : T1.C2
)
FROM T1, T2;

--echo # Requirements for Keys in JSON_DUALITY_OBJECT:
--echo # There must be a key named "_id" in root object representing
--echo # primary key of the root table. Absence of such key_name in the
--echo # root table json_duality_key_value_pairs must result in an error.

--error ER_JDV_INVALID_DEFINITION_ID_KEY_NOT_USED_BY_ROOT_TABLE
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "C1" : T1.C1,
    "C2" : T1.C2,
    "T2" : (
                SELECT JSON_ARRAYAGG(
                        JSON_DUALITY_OBJECT(
                            "C1" : T2.C1,
                            "C2" : T2.C2
                        )
                )
                FROM T2
                WHERE T1.C1 = T2.C2
            )
)
FROM T1;

--echo # Requirements for Values in JSON_DUALITY_OBJECT:
--echo # It must either be a column name, JSON_DUALITY_OBJECT
--echo # or JSON_ARRAYAGG. Usage of any other expression must
--echo # result in a syntax error.

--error ER_JDV_INVALID_DEFINITION_WRONG_FIELD_TYPE
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : T1.C1,
    "C2" : 1,
    "T2" : (
                SELECT JSON_ARRAYAGG(
                        JSON_DUALITY_OBJECT(
                            "C1" : C1,
                            "C2" : C2
                        )
                )
                FROM T2
                WHERE T1.C1 = T2.C2
            )
)
FROM T1;

--echo # Requirements for column name used in the JSON_DUALITY_OBJECT:
--echo # It must reference a valid column in the table that is being
--echo # projected.

--error ER_BAD_FIELD_ERROR
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : T1.C1,
    "C2"  : T1.C2,
    "T2"  : (
                SELECT JSON_ARRAYAGG(
                        JSON_DUALITY_OBJECT(
                            "C1" : T2.C1,
                            "C2" : T2.C3
                        )
                )
                FROM T2
                WHERE T1.C1 = T2.C2
            )
)
FROM T1;

--echo # Projecting virtual columns isn't supported and must result into a
--echo # semantic error if done.

ALTER TABLE T2 ADD COLUMN C3 INT GENERATED ALWAYS AS (C1+C2) VIRTUAL;

--error ER_JDV_INVALID_DEFINITION_COLUMN_TYPE_NOT_SUPPORTED
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : T1.C1,
    "C2" : T1.C2,
    "T2" : (
                SELECT JSON_ARRAYAGG(
                        JSON_DUALITY_OBJECT(
                            "C1" : T2.C1,
                            "C2" : T2.C2,
                            "VIRTUAL": C3
                        )
                )
                FROM T2
                WHERE T1.C1 = T2.C2
            )
)
FROM T1;

--echo # Unlike top-level select, WHERE clause is supported here but it
--echo # must only contain one expression, and that must be of the below form:
--echo # [schema_name .] child_table_name . column_name =
--echo # [schema_name .] parent_table_name . column_name

--error ER_JDV_INVALID_DEFINITION_NO_WHERE_CONDITION_IN_SUBOBJECT
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id": T2.C1,
    "C2" : T2.C2,
    "T1" : (
                SELECT JSON_DUALITY_OBJECT(
                    "C1" : T1.C1,
                    "C2" : T1.C2
                )
                FROM T1
           )
)
FROM T2;

--echo # Usage of any other type of condition or usage of AND/OR operator
--echo # in the condition must result in a syntax error.

--error ER_JDV_INVALID_DEFINITION_WRONG_WHERE_FORMAT_FOR_SUBOBJECT
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id": T2.C1,
    "C2" : T2.C2,
    "T1" : (
                SELECT JSON_DUALITY_OBJECT(
                    "C1" : T1.C1,
                    "C2" : T1.C2
                )
                FROM T1
                WHERE T1.C1 = T2.C2 AND 1=1
           )
)
FROM T2;

--echo # The JSON_ARRAYAGG() must contain JSON_DUALITY_OBJECT()
--echo # and JSON_DUALITY_OBJECT() must not be empty.

--error ER_JDV_INVALID_DEFINITION_NO_JSON_OBJ_IN_ARRAYAGG
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "C1" : T1.C1,
    "C2" : T1.C2,
    "T2" : (
                SELECT JSON_ARRAYAGG(T2.C2)
                FROM T2
                WHERE T1.C1 = T2.C2
            )
)
FROM T1;

--echo # Requirements for table_annotations_expression

--echo # Tables being projected (i.e. root_table_name or child_table_name
--echo # clauses) in the duality view can optionally have table annotations.
--echo # The following table annotations must be supported:
--echo #    INSERT
--echo #    DELETE
--echo #    UPDATE

CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2" : C2
)
FROM T1;

CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    WITH (INSERT, UPDATE, DELETE)
    "_id" : C1,
    "C2" : C2
)
FROM T1;

--echo # Support for column list
--echo # The CREATE OR REPLACE JSON DUALITY VIEW statement does not
--echo # support column list, using column list in the statement should
--echo # result in a syntax error. View column name data is automatically
--echo # added for the JSON duality view.

--error ER_JDV_INVALID_DEFINITION_COLUMN_LIST_NOT_SUPPORTED
CREATE OR REPLACE JSON DUALITY VIEW dv1 (data)
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2"  : C2
)
FROM T1;

--echo # Requirement-9: Base Table Requirement for Participating Tables

CREATE OR REPLACE VIEW V1 AS SELECT C1, C2 FROM T1;

--error ER_JDV_INVALID_DEFINITION_NON_BASE_TABLE_NOT_SUPPORTED
CREATE JSON DUALITY VIEW dv2
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2"  : C2
)
FROM V1;

CREATE TEMPORARY TABLE T3 AS
SELECT * FROM T1;

--error ER_VIEW_SELECT_TMPTABLE
CREATE JSON DUALITY VIEW dv2
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2"  : C2
)
FROM T3;

--echo # All participating tables must have a defined primary key.

CREATE TABLE T4 (C1 INT, C2 INT);

--error ER_JDV_INVALID_DEFINITION_TABLE_WITHOUT_PK_FOUND
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2"  : C2
)
FROM T4;

--error ER_JDV_INVALID_DEFINITION_TABLE_WITHOUT_PK_FOUND
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "_id" : C1,
    "C2"  : C2,
    "T4"  : (
                SELECT JSON_ARRAYAGG(
                            JSON_DUALITY_OBJECT(
                                "C1" : T4.C1,
                                "C2" : T4.C2
                            )
                )
                FROM T4
                WHERE T4.C1 = T1.C1
            )
)
FROM T1;

--echo # The projection must include the primary key of every
--echo # participating table. If any participating table lacks a
--echo # primary key, or if the primary key is omitted from the projection,
--echo # a semantic error must be generated.

--error ER_JDV_INVALID_DEFINITION_TABLE_WITHOUT_PK_PROJECTION_FOUND
CREATE OR REPLACE JSON DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    "C2" : C2
)
FROM T1;

--echo # Child tables being projected as part of JSON DUALITY VIEW can
--echo # be related to parent tables in one of below 2 types:
--echo #    1. PK - FK Relationship (or Referential Integrity)
--echo #    2. PK - Any Column Relationship

CREATE TABLE T5 (
    C1 INT PRIMARY KEY,
    C2 INT,
    FOREIGN KEY (C1) REFERENCES T1(C1)
);

--echo # 11.1 PK-FK Relationship (or Referential Integrity):

--error ER_JDV_INVALID_DEFINITION_RELATIONSHIP_RULES_VIOLATED
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
       "_id": T5.C1,
       "C2": T5.C2,
       "T1": (
              SELECT JSON_DUALITY_OBJECT(
                     "C1": T1.C1,
                     "C2": T1.C2
              )
              FROM T1 WHERE T1.C2 = T5.C2
       )
) FROM T5;

--error ER_JDV_INVALID_DEFINITION_RELATIONSHIP_RULES_VIOLATED
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
       "_id": T1.C1,
       "C2": T1.C2,
       "T5": (
              SELECT JSON_ARRAYAGG(
                     JSON_DUALITY_OBJECT(
                            "C1": T5.C1,
                            "C2": T5.C2
                     )
              )
              FROM T5 WHERE T1.C2 = T5.C2
       )
) FROM T1;

CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
       "_id": T1.C1,
       "C2": T1.C2,
       "T5": (
              SELECT JSON_DUALITY_OBJECT(
                     "C1": T5.C1,
                     "C2": T5.C2
              )
              FROM T5 WHERE T1.C1 = T5.C1
       )
) FROM T1;

CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
       "_id": T5.C1,
       "C2": T5.C2,
       "T1": (
              SELECT JSON_ARRAYAGG(
                            JSON_DUALITY_OBJECT(
                                   "C1": T1.C1,
                                   "C2": T1.C2
                            )
              )
              FROM T1 WHERE T1.C1 = T5.C1
       )
) FROM T5;

--echo # 11.2 PK - Any column Relationship:

CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
       "_id": T5.C1,
       "C2": T5.C2,
       "T1": (
              SELECT JSON_DUALITY_OBJECT(
                     "C1": T1.C1,
                     "C2": T1.C2
              )
              FROM T1 WHERE T1.C1 = T5.C2
       )
) FROM T5;

CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(
       "_id": T1.C1,
       "C2": T1.C2,
       "T5": (
              SELECT JSON_ARRAYAGG(
                     JSON_DUALITY_OBJECT(
                            "C1": T5.C1,
                            "C2": T5.C2
                     )
              )
              FROM T5 WHERE T1.C1 = T5.C2
       )
) FROM T1;

--echo # In a case where a parent table is Foreign key child of a child_table,
--echo # usage of the DELETE tag with the child_table must result in a
--echo # semantic error.

--error ER_JDV_INVALID_TABLE_ANNOTATIONS_FOR_SINGLETON_OBJ
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE, DELETE)
       "_id": T1.C1,
       "C2": T1.C2,
       "T2": (
              SELECT JSON_DUALITY_OBJECT(WITH DELETE
                     "C1": T2.C1,
                     "C2": T2.C2
              )
              FROM T2
              WHERE T1.C1 = T2.C1
       )
) FROM T1;

--error ER_JDV_INVALID_TABLE_ANNOTATIONS_FOR_SINGLETON_OBJ
CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE, DELETE)
       "_id": T1.C1,
       "C2": T1.C2,
       "T2": (
              SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE, DELETE)
                     "C1": T2.C1,
                     "C2": T2.C2
              )
              FROM T2
              WHERE T1.C1 = T2.C1
       )
) FROM T1;

CREATE OR REPLACE JSON DUALITY VIEW dv1 AS
SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE, DELETE)
       "_id": T1.C1,
       "C2": T1.C2,
       "T2": (
              SELECT JSON_DUALITY_OBJECT(WITH (INSERT, UPDATE)
                     "C1": T2.C1,
                     "C2": T2.C2
              )
              FROM T2
              WHERE T1.C1 = T2.C1
       )
) FROM T1;

CREATE TABLE T6 (C1 INT PRIMARY KEY, C2 INT);
ALTER TABLE T2 ADD C4 INT REFERENCES T6(C1);

CREATE OR REPLACE
ALGORITHM = MERGE
DEFINER = current_user()
SQL SECURITY DEFINER
JSON RELATIONAL DUALITY VIEW dv1
AS SELECT JSON_DUALITY_OBJECT(
    WITH (INSERT, UPDATE, DELETE)
    "_id" : C1,
    "C2"  : C2,
    "T2"  : (
                SELECT JSON_ARRAYAGG(
                            JSON_DUALITY_OBJECT(
                                "C1" : C1,
                                "C2" : C2,
                                "T6" : (
                                            SELECT JSON_DUALITY_OBJECT(
                                                WITH (INSERT, UPDATE)
                                                "C1" : C1,
                                                "C2" : C2
                                            )
                                            FROM T6
                                            WHERE T6.C1 = T2.C4
                                       )
                            )
                )
                FROM T2
                WHERE T1.C1 = T2.C2
            )
)
FROM T1;

--echo # Requirements for DROP VIEW

--echo # If a duality view with the view_name is present, regardless
--echo # of whether IF EXISTS clause is there or not, the statement
--echo # DROP VIEW must drop the view.

DROP VIEW V, V1;
DROP VIEW IF EXISTS dv1, dv2;

--echo # Cleanup
DROP TABLE T1, T2, T3, T4, T5, T6;
