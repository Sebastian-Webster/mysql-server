# During FULLTEXT index creation the table is re-built, which causes
# the tablespace to be momentarily deleted from the data dictionary.
# There should be no impact on another session trying to concurrently
# access the table.

--source include/have_debug_sync.inc

CREATE TABLE t1 (c1 INT, c2 TEXT);
INSERT INTO t1 VALUES (1, "one"), (2, "two"), (3, "three");
SET DEBUG_SYNC = 'alter_table_inplace_after_lock_downgrade SIGNAL downgraded WAIT_FOR can_go';
--send CREATE FULLTEXT INDEX ind ON t1 ( c2 );
--connect (con1,localhost,root,,)
SET DEBUG_SYNC = 'now WAIT_FOR downgraded';
SELECT * FROM t1;
SET DEBUG_SYNC = 'now SIGNAL can_go';
--connection default
--reap
DROP TABLE t1;

# The scenario above may rely on the engine storing information about
# tablespaces outside of data dictionary. This happens in InnoDB,
# which maintains information about its use of the filesystem and
# provides an internal API, which is often used in preference to
# the data dictionary. However, when a tablespace is discarded, as
# in the scenario below, it no longer resides in the filesystem, and
# consequently the internal API cannot be used to access its
# properties. In this case the code may fall back on lookking up the
# data dictionary, so it is necessary to ensure that the temporary
# removal due to rebuild does not impact the other session in this
# scenario either.

--disable_query_log
call mtr.add_suppression("\\[Warning\\] \\[MY-011996\\] \\[InnoDB\\] Tablespace for table `[^`]*`.`t1` is set as discarded.");
--enable_query_log

call mtr.add_suppression("\\[Warning\\] .*MY-\\d+.* Cannot add field.*");
CREATE TABLE t1 (c1 INT, c2 TEXT);
ALTER TABLE t1 DISCARD TABLESPACE;
SET DEBUG_SYNC = 'alter_table_inplace_after_lock_downgrade SIGNAL downgraded WAIT_FOR can_go';
--send CREATE FULLTEXT INDEX ind ON t1 ( c2 );
--connection con1
SET DEBUG_SYNC = 'now WAIT_FOR downgraded';
--error ER_TABLESPACE_DISCARDED
SELECT * FROM t1;
SET DEBUG_SYNC = 'now SIGNAL can_go';
--connection default
--reap
DROP TABLE t1;

